# 操作系统
## 启动计算机
### 阶段一：硬件唤醒与复位 (Power On & Reset)
> 时间：0ms - 100ms

1. 当按下电源键时，电源供应器（PSU）开始工作，当电压稳定后，它会向主板发送一个“Power Good”信号。
2. CPU 复位 (Reset)：主板收到信号后，撤销对 CPU 的“复位”保持。此时，CPU 的寄存器被强制初始化为特定状态。
   > 这里的“CPU 的寄存器被强制初始化”是由CPU内部的微码完成的，微码指的是CPU内部ROM中的“固件指令集”。它可以直接驱动内部数据总线，把值写入到寄存器中。此时CS(Code Segment,代码指针寄存器)被初始化为0xF000,IP(Instruction Pointer，指令指针寄存器)被初始化为0xFFF0。而CPU内部维持了一个不可见的Cache of Segment Descriptor Base（段描述符基址缓存），它被初始化为0xFFFF。同时<font color="red">地址总线中的A31-A20位被强制置为高电平（表示1，Intel 手册叫 “Reset vector” 或 “Boot strap” 区域）。</font>由于硬件电路在复位到微码状态时，它的走线方式为“段描述符基址 + IP”这样的方式，因此计算得到的物理地址为0xFFFFFFF0。

3. `0xFFFFFFF0`这一地址会被送到CPU 内部的PCIe Root Complex（或叫 System Agent），在这一部件中会把地址和一组硬连线寄存器进行比对：
    - 0x0000_0000 – Top-of-RAM → DRAM 控制器
    - 0xFE00_0000 – 0xFFFF_FFFF → SPI Flash 窗口
    - 其他区间 → PCIe、MMIO、APIC …

    此时命中 Flash 窗口，CPU 自己就把事务转成SPI周期，通过专用SPI引脚直接去找焊在主板上的 8-pin/16-pin Flash；这里通常保存了一个远跳转指令，CPU读取后会把下一条要读取的指令地址放在跳转后的位置，也就是bios的入口处。远跳转指令执行后，Cache of Segment Descriptor Base会被改为0x000F0000，以回到真实的实模式状态下，地址总线中的强制高电平也会被解除。


总而言之，微观流程最终为：
1. Power On。
2. CPU Reset：
   - CS_Selector = 0xF000
   - CS_Base (Hidden) = 0xFFFF0000
   - EIP = 0xFFF0
3. Address Generation：CPU 生成物理地址 0xFFFF0000 + 0xFFF0 = 0xFFFFFFF0。
4. Routing：芯片组识别该地址，将其路由至 SPI Flash 芯片的尾部。
5. Fetch：CPU 拿到 Flash 中最后的 16 字节指令。这里的指令通常都是远跳转指令，跳转到BIOS的入口处。
   > 为什么是最后16字节？因为0xFFFFFFF0 - 0xFFFFFFFF（4GB的内存空间顶端，至于为什么是4GB，因为早期只有32位地址总线。这么做某种意义上也是兼容旧的设计，而且也足够用，只要保证0xFFFFFFF0一定会被芯片组映射到SPI Flash中读取即可。）
6. Execute：执行 JMP 指令。
7. State Change：
   - 执行 JMP 后，CS Base 被更新，EIP 指向新的 BIOS 入口。
   - 此时，CPU 正式开始执行 BIOS 的 POST（自检）代码。

### 阶段二：实模式下的 BIOS 环境 (Legacy BIOS)
现在的状态是：

- CPU 模式：16 位实模式 (Real Mode)。
- CS:IP：跳转到了 BIOS 代码的主体部分（通常在低端内存 0xF0000 区域）。
- 内存视角：CPU 现在能“看”到 1MB 的内存空间 (0x00000 - 0xFFFFF)。

此时，CPU会开始执行BIOS的代码（BIOS本质上也是一个程序），BIOS的代码主要做了两件事：
<font color="red">**建立IVT(Interrupt Vector Table， 中断向量表)以及提供BIOS中断服务。**</font>
> 中断向量表的功能在于提供硬件中断操作。
1. 物理位置与结构
        在 实模式 (Real Mode) 下，CPU 硬件设计死了：内存的最开始 1KB 就是 IVT。
        - 地址范围：0x00000 - 0x003FF。
        - 大小：1024 字节。
        - 容量：256 个表项（也就是支持 0-255 号中断）。

    每个表项的结构（关键）： 每个中断向量占据 4 个字节。它存储了一个“远指针 (Far Pointer)”，指向实际处理代码的位置。 
    - 低 2 字节：偏移地址 (Offset / IP)
    - 高 2 字节：段地址 (Segment / CS)

    <font color="red">注意：x86 是 小端序 (Little Endian)。如果读取内存 0x00000 看到的是 `12 34 56 78`，那么：
    ```
        IP = 0x3412

        CS = 0x7856

        跳转目标 = 0x7856:0x3412
    ```
    </font>
2. 工作原理：CPU 如何查表？
    
    当发生中断（例如按下键盘触发 INT 9，或者代码执行 INT 0x10）时，CPU 内部硬件会自动执行以下微操：
    1. 计算入口地址：**中断号 × 4**。
    例如 INT 0x10（显卡服务），地址就是 0x10 × 4 = 0x40。
    2. 取地址：CPU 直接去内存 0x00040 处读取 4 个字节。
    3. 保存现场：CPU 自动把当前的标志寄存器 (FLAGS)、CS、IP 压入堆栈（这也是为什么堆栈必须先设好的原因！）。
    4. 飞跃：CPU 将读取到的 CS 和 IP 赋值给寄存器，执行流瞬间跳转到中断服务程序 (ISR)。

    > 为什么BIOS要建立中断向量表？在我的理解中，最重要的原因是因为此时操作系统还没有被加载，自然也就不包含任何的驱动程序。此时如果我们需要进行某些操作，例如把操作系统从磁盘读取到内存进行加载（软件中断），或者通过键盘按键执行某个操作（硬件中断），就必须“告诉”CPU当我使用这些方法时，你需要执行哪些指令。中断向量表实际上是提供了一系列“函数”的地址，让CPU在执行中断操作时知道要去哪里“找到应该怎么做”。

    > 而驱动程序的本质，就是覆盖IVT表中对应的地址指针，使其指向驱动程序的代码。装好了驱动以后，CPU在执行对应中断的时候调用的“函数”就是我们的驱动程序，而不是BIOS预设好的代码。（注意，这一原理仅适用于实模式，在保护模式以及别的模式下，IVT不再使用，驱动程序的设计更加复杂。）

    > 当我们产生某个中断（比如键盘操作触发中断）时，CPU首先会通过中断号 * 4的方式，计算中断号所对应的中断向量表中的4字节地址。例如，按下键盘触发的中断号是`09h`，因此中断向量表中的地址为`09h * 4 = 0x24`，CPU会到内存中`0x24`这个起始位置读取4个字节，前面2个字节保存在偏移地址指针（IP）中，而后面2个字节则保存在段指针（CS）中。这4个字节共同组成了一个**远地址**，对应着实际的键盘处理函数的位置。

    > IVT 里放的“远地址”是 16 位段 + 16 位偏移，共 32 位（4 字节），能表示的极限地址就是`0xFFFF:0xFFFF → 0x10FFEF`，仍在 1 MB 范围内。硬件设计时已经掐死了：只要 CPU 跑在实模式，中断处理程序必须落在 1 MB 以内。

实战演示：按下 "A" 键时发生了什么？
跟踪一下在实模式下按下键盘 "A" 键的瞬间：

1. 硬件层：键盘控制器通过电路向 CPU 发送信号（IRQ 1）。
2. 中断控制器 (PIC)：把 IRQ 1 转换成中断号 0x09，告诉 CPU。
3. CPU 查表：CPU 计算 9 × 4 = 36 (0x24)。它去内存 0x00024 读取地址。
4. 跳转 BIOS 代码：CPU 跳到了 BIOS 预设的键盘处理函数。
5. BIOS 干活：BIOS 读取端口，发现是 "A" 的扫描码，把它转成 ASCII 'a'，存入 BIOS 数据区（BDA）的缓冲区。
6. 中断返回 (IRET)：BIOS 执行完后，执行 IRET 指令，CPU 从堆栈弹出之前的 CS:IP，回到刚才被中断的地方继续运行。

### 阶段三、四 神奇的 0x7C00 与 引导扇区
在这一时刻，BIOS已经准备好了IVT，中断服务也可以用了。下一步就是加载我们的操作系统了。
这就涉及到了操作系统中一个最著名的数字：`0x7C00`。
首先，BIOS会检查硬盘中的**第一个扇区（Sector 0, Cylinder 0, Head 0）**。
- 物理硬盘的最小读写单位就是扇区，通常是 512 字节。
- BIOS 会把这 512 字节读入内存 <font color="red">**（注意，读取到`0x7C00`为起始地址的512个字节中）**</font>。

读取这512字节后，BIOS会检查最后两个字节（第510、511字节）。
 - 如果是 `0x55` 和 `0xAA`：BIOS 认为“这是引导程序”，于是跳转去执行。
 - 如果不是：BIOS 认为这只是数据，跳过，去检查下一个设备。

> 为什么是读取到`0x7C00`，而不是什么别的位置？这是由于0x0000-0x003ff保存了IVT，而BIOS从0xF0000开始,操作系统又想要尽可能放在低地址（例如`0x00500`）的位置，因此IBM工程师们约定好放在了`0x7C00`（32KB）处，既不会干扰IVT以及操作系统加载，又留下了高地址空间作为栈来使用。


## 开发操作系统
### HellWorld
在BIOS的工作完成之后，我们就可以开始尝试加载我们自己的操作系统了。这里我用的是WSL（Windows SubSystem Linux）环境下的NASM以及QEMU进行模拟。
HelloWorld操作系统的代码如下：
```asm
[org 0x7c00]    ; 告诉编译器这段代码会被加载到 0x7c00

    ; --- 初始化 ---
    mov ax, 0
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7c00 ; 设置栈顶在 0x7c00，栈是向下生长的，安全！

    ; --- 打印字符 'H' ---
    mov ah, 0x0e   ; BIOS 0x10 中断的 "打印字符" 功能
    mov al, 'H'
    int 0x10

    ; --- 打印字符 'i' ---
    mov al, 'i'
    int 0x10

    ; --- 打印字符 '!' ---
    mov al, '!'
    int 0x10

    ; --- 死循环 ---
    jmp $          ; 让 CPU 停在这里，否则它会乱跑执行后面的垃圾数据

    ; --- 填充与签名 ---
    times 510-($-$$) db 0  ; 填充 0 直到第 510 字节
    dw 0xaa55              ; 它是引导扇区的标志！
```
这里需要解释的几个部分：
1. 首先就是`org 0x7c00`，org是origin的缩写，这句话的意思是告诉编译器，以下代码的地址都要加上`0x7C00`的偏移，才是代码在物理内存中的实际地址。这句代码在编译后并不会成为操作系统代码的一部分，只是为了保证在模拟时按照真实操作系统的情况进行加载。
2. 初始化的部分完成了对于通用寄存器以及段寄存器和栈基址和栈顶指针的的加载，其中`SS:SP`分别表示栈基址和栈顶指针，它们分别初始化为`0x00`和`0x7C00`。因此`0x00-0x7C00`这`32KB`的空间就成了我们的IVT、BIOS数据以及引导扇区的保存处。
3. `ax`是一个通用寄存器，它的特殊之处在于**可以通过指定功能号来告诉ROM例程需要调用的功能**。例如`mov ah, 0x0e`就是告诉ROM例程，需要执行"打印字符"的功能。
    > 与`ax`类似的还有`bx、cx、dx`这三个通用寄存器，它们都可以拆成高8位和低8位的两个寄存器使用，高位就是high，写做“ah”，低位就是low，写作“al”。在调用功能时，`ah`用于指定功能号，`al`用作保存需要使用的值。
4. `int 0x10`这里的`int`指的是`interrupt`,通过后面的中断号来执行相应的中断。这里的`0x10`指的就是BIOS视频中断，完成显示功能。
5. `jmp`是跳转指令,`$`则表示当前指令地址，这里就是让操作系统一直跳转到`jmp $`这条指令处，模拟死循环，避免操作系统去读更低地址的代码，从而导致读到无效区域导致崩溃。
6. `times`是一个伪指令，用于指定某操作重复的次数。后面的`510-($-$$)`中，`$$`表示的是栈的起始地址（0x7C00），所以`$-$$`就是在计算我们编写的代码占用了多少个字节，再用510-字节数得出需要填充的字节数量，再用`db(define byte)`命令向其中填充0。最后使用`dw 0xaa55`把最后两字节填充为`0x55 0xaa`（小端序）。

### 实现“打字机”功能
**目标**：系统启动后，屏幕黑屏等待。当您按下键盘上的任意字符键，屏幕上立刻显示该字符。这需要无限循环进行。
1. 键盘输入服务 (BIOS Keyboard Service)

    这是“读取按键”的方法。
    - 中断号：`int 0x16`
    - 功能号：ah = 0x00 (代表“读取下一个按键”)
    - 行为：这是一个阻塞 (Blocking) 调用。如果不按键，CPU 会停在这行指令不动，直到按下一个键。

    返回值：
    - al 寄存器：存放按键的 ASCII 码（比如按下 'A'，al 就是 0x41）。
    - ah 寄存器：存放按键的扫描码（Scan Code，也就是键盘上那个键的物理位置编号，暂时不用管）。

2. 屏幕输出服务 (BIOS Video Service)
    - 中断号：int 0x10
    - 功能号：ah = 0x0e (代表“电传打印模式”)

    参数：
    - al 寄存器：要打印的字符的 ASCII 码。

代码如下：
```asm
[org 0x7C00]

    mov ax, 0
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00

loop_start:
    mov ah, 0x00
    int 0x16

    mov ah, 0x0e
    int 0x10

    jmp loop_start

    times 510-($-$$) db 0
    dw 0xaa55
```
其实没有太多特殊的地方，主要就是设置循环的代码`loop_start：`。然后注意`int 0x16`中断会使得计算机等待用户输入，用户按下按键后会把按键值保存在`al`中，直接指定功能号并使用`int 0x10`中断进行显示即可。最后通过跳转到开头实现不断读取字符的功能。